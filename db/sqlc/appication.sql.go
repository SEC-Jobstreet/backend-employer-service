// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: appication.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApplication = `-- name: CreateApplication :one
INSERT INTO applications (
    candidate_id, 
    job_id,
    status
) VALUES (
    $1, $2, $3
) RETURNING id, candidate_id, job_id, status, message, updated_at, created_at
`

type CreateApplicationParams struct {
	CandidateID int64  `json:"candidate_id"`
	JobID       int64  `json:"job_id"`
	Status      string `json:"status"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, createApplication, arg.CandidateID, arg.JobID, arg.Status)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.CandidateID,
		&i.JobID,
		&i.Status,
		&i.Message,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getApplication = `-- name: GetApplication :one
SELECT id, candidate_id, job_id, status, message, updated_at, created_at FROM applications
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetApplication(ctx context.Context, id int64) (Application, error) {
	row := q.db.QueryRow(ctx, getApplication, id)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.CandidateID,
		&i.JobID,
		&i.Status,
		&i.Message,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listApplications = `-- name: ListApplications :many
SELECT id, candidate_id, job_id, status, message, updated_at, created_at FROM applications
WHERE 
    (candidate_id = $1 OR $1 = 0)
    AND (job_id = $2 OR $2 = 0)
    AND (status = $3 OR $3 = '')
ORDER BY id
LIMIT $5
OFFSET $4
`

type ListApplicationsParams struct {
	CandidateID int64  `json:"candidate_id"`
	JobID       int64  `json:"job_id"`
	Status      string `json:"status"`
	O           int32  `json:"o"`
	L           int32  `json:"l"`
}

func (q *Queries) ListApplications(ctx context.Context, arg ListApplicationsParams) ([]Application, error) {
	rows, err := q.db.Query(ctx, listApplications,
		arg.CandidateID,
		arg.JobID,
		arg.Status,
		arg.O,
		arg.L,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Application{}
	for rows.Next() {
		var i Application
		if err := rows.Scan(
			&i.ID,
			&i.CandidateID,
			&i.JobID,
			&i.Status,
			&i.Message,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStatusApplication = `-- name: UpdateStatusApplication :one
UPDATE applications
SET
    status = $1,
    message = COALESCE($2, message),
    updated_at = $3
WHERE
    id = $4
RETURNING id, candidate_id, job_id, status, message, updated_at, created_at
`

type UpdateStatusApplicationParams struct {
	Status    string      `json:"status"`
	Message   pgtype.Text `json:"message"`
	UpdatedAt time.Time   `json:"updated_at"`
	ID        int64       `json:"id"`
}

func (q *Queries) UpdateStatusApplication(ctx context.Context, arg UpdateStatusApplicationParams) (Application, error) {
	row := q.db.QueryRow(ctx, updateStatusApplication,
		arg.Status,
		arg.Message,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Application
	err := row.Scan(
		&i.ID,
		&i.CandidateID,
		&i.JobID,
		&i.Status,
		&i.Message,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
